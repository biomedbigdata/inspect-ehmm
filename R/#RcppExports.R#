# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Forward-backward algorithm
#'
#' Forward-backward algorithm using the scaling technique.
#' That's more stable (and maybe even faster) than the method with the logarithm.
#' Warning: this function overwrites the lliks matrix. 
#' @param initP matrix of initial probabilities: each column corresponds to a sequence
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @param posteriors the posteriors matrix where the posteriors will be written.
#' its value when the function is called does not matter, but it needs to have
#' the right dimensions (rows are states and columns are observations).
#' @param nthreads number of threads used. Sequences of observations are
#' processed independently by different threads (if \code{length(seqlens) > 1}).
#' @return a list with the following arguments:
#'    \item{posteriors}{posterior probability of being in a certain state for a certain datapoint.
#'     Same matrix used as input argument.}
#'    \item{tot_llik}{total log-likelihood of the data given the hmm model.}
#'    \item{new_trans}{update for the transition probabilities (it is already normalized).}
#' @export
forward_backward <- function(initP, trans, lliks, seqlens, posteriors, nthreads = 1L) {
    .Call('_ehmm_forward_backward', PACKAGE = 'ehmm', initP, trans, lliks, seqlens, posteriors, nthreads)
}

#' Viterbi algorithm
#'
#' Standard viterbi algorithm in the log space
#' @param initP matrix of initial probabilities: each column corresponds to a sequence
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @return a list with the following arguments:
#'    \item{vpath}{viterbi path}
#'    \item{vllik}{log-likelihood of the viterbi path}
#'    \item{vscores}{viterbi scores}
#' @export
viterbi <- function(vscores, initP, trans, lliks, seqlens, endstate) {
    .Call('_ehmm_viterbi', PACKAGE = 'ehmm', vscores, initP, trans, lliks, seqlens, endstate)
}

testSchedule <- function(jobs, nthreads, type) {
    .Call('_ehmm_testSchedule', PACKAGE = 'ehmm', jobs, nthreads, type)
}

testColPost <- function(post, m2u, nthreads) {
    .Call('_ehmm_testColPost', PACKAGE = 'ehmm', post, m2u, nthreads)
}

tabFast <- function(counts) {
    .Call('_ehmm_tabFast', PACKAGE = 'ehmm', counts)
}

labelCounts <- function(empirical, theoretical) {
    .Call('_ehmm_labelCounts', PACKAGE = 'ehmm', empirical, theoretical)
}

clusterAverages2 <- function(counts, coords, clusters, nthreads = 1L) {
    .Call('_ehmm_clusterAverages2', PACKAGE = 'ehmm', counts, coords, clusters, nthreads)
}

clusterAverages <- function(counts, clusters, nthreads = 1L) {
    .Call('_ehmm_clusterAverages', PACKAGE = 'ehmm', counts, clusters, nthreads)
}

fillPosteriors <- function(coords, clusters, nclust, nthreads = 1L) {
    .Call('_ehmm_fillPosteriors', PACKAGE = 'ehmm', coords, clusters, nclust, nthreads)
}

rowdotprod <- function(counts, besselCorr = TRUE, nthreads = 1L) {
    .Call('_ehmm_rowdotprod', PACKAGE = 'ehmm', counts, besselCorr, nthreads)
}

discretizeRows <- function(scores, nlevels, nthreads = 1L) {
    .Call('_ehmm_discretizeRows', PACKAGE = 'ehmm', scores, nlevels, nthreads)
}

splitAxes <- function(scores, nsplit, nthreads = 1L) {
    .Call('_ehmm_splitAxes', PACKAGE = 'ehmm', scores, nsplit, nthreads)
}

splitAxesInt <- function(scores, nsplit, nthreads = 1L) {
    .Call('_ehmm_splitAxesInt', PACKAGE = 'ehmm', scores, nsplit, nthreads)
}

KL_dist_mat_LN <- function(mus, sigmasqs, nthreads = 1L) {
    .Call('_ehmm_KL_dist_mat_LN', PACKAGE = 'ehmm', mus, sigmasqs, nthreads)
}

KL_dist_mat <- function(nbs, r, nthreads = 1L) {
    .Call('_ehmm_KL_dist_mat', PACKAGE = 'ehmm', nbs, r, nthreads)
}

findUniqueSeeds <- function(counts, permutation, k) {
    .Call('_ehmm_findUniqueSeeds', PACKAGE = 'ehmm', counts, permutation, k)
}

support_openmp <- function() {
    .Call('_ehmm_support_openmp', PACKAGE = 'ehmm')
}

llik2posteriors <- function(lliks, mix_coeff, posteriors, nthreads = 1L) {
    .Call('_ehmm_llik2posteriors', PACKAGE = 'ehmm', lliks, mix_coeff, posteriors, nthreads)
}

#' Group unique values of a vector
#'
#' @param values a vector of integers. If they are not integers they will be
#'     casted to integers.
#' @return a list with the following items:
#'        \item{values}{unique and sorted values of \code{v}}
#'        \item{map}{a vector such that \code{v[i] = values[map[i]+1]} for every i}
#'    @export
mapToUnique <- function(values) {
    .Call('_ehmm_mapToUnique', PACKAGE = 'ehmm', values)
}

getMultinomConst <- function(counts, nthreads = 1L) {
    .Call('_ehmm_getMultinomConst', PACKAGE = 'ehmm', counts, nthreads)
}

getMultinomConstSW <- function(counts, nthreads = 1L) {
    .Call('_ehmm_getMultinomConstSW', PACKAGE = 'ehmm', counts, nthreads)
}

sumAt <- function(values, map, size, zeroIdx = FALSE) {
    .Call('_ehmm_sumAt', PACKAGE = 'ehmm', values, map, size, zeroIdx)
}

colSumsInt <- function(nums, nthreads = 1L) {
    .Call('_ehmm_colSumsInt', PACKAGE = 'ehmm', nums, nthreads)
}

colSumsDouble <- function(nums, nthreads = 1L) {
    .Call('_ehmm_colSumsDouble', PACKAGE = 'ehmm', nums, nthreads)
}

rowSumsDouble <- function(mat, nthreads = 1L) {
    .Call('_ehmm_rowSumsDouble', PACKAGE = 'ehmm', mat, nthreads)
}

lLikMat <- function(counts, models, ucs, mConst, lliks, nthreads = 1L, type = "negmultinom") {
    invisible(.Call('_ehmm_lLikMat', PACKAGE = 'ehmm', counts, models, ucs, mConst, lliks, nthreads, type))
}

lLikGapMat <- function(counts, models, ucs, mConst, lliks, nthreads = 1L, type = "negbinom") {
    invisible(.Call('_ehmm_lLikGapMat', PACKAGE = 'ehmm', counts, models, ucs, mConst, lliks, nthreads, type))
}

pwhichmax <- function(posteriors, nthreads = 1L) {
    .Call('_ehmm_pwhichmax', PACKAGE = 'ehmm', posteriors, nthreads)
}

fitNB_inner <- function(counts, posteriors, initR = -1, tol = 1e-8, verbose = FALSE, nthreads = 1L) {
    .Call('_ehmm_fitNB_inner', PACKAGE = 'ehmm', counts, posteriors, initR, tol, verbose, nthreads)
}

fitModels <- function(counts, posteriors, models, ucs, type = "indep", tol = 1e-8, verbose = FALSE, nthreads = 1L) {
    .Call('_ehmm_fitModels', PACKAGE = 'ehmm', counts, posteriors, models, ucs, type, tol, verbose, nthreads)
}

fitModelsGapMat <- function(counts, posteriors, models, ucs, type = "indep", tol = 1e-8, nthreads = 1L) {
    .Call('_ehmm_fitModelsGapMat', PACKAGE = 'ehmm', counts, posteriors, models, ucs, type, tol, nthreads)
}

checkInterrupt <- function() {
    invisible(.Call('_ehmm_checkInterrupt', PACKAGE = 'ehmm'))
}

smallWeightHamiltonianPath <- function(dmat) {
    .Call('_ehmm_smallWeightHamiltonianPath', PACKAGE = 'ehmm', dmat)
}

setDim_unsafe <- function(obj, dims) {
    invisible(.Call('_ehmm_setDim_unsafe', PACKAGE = 'ehmm', obj, dims))
}

setDimnames_unsafe <- function(obj, dimnames) {
    invisible(.Call('_ehmm_setDimnames_unsafe', PACKAGE = 'ehmm', obj, dimnames))
}

bindCols_numeric <- function(vlist, nthreads = 1L) {
    .Call('_ehmm_bindCols_numeric', PACKAGE = 'ehmm', vlist, nthreads)
}

bindCols <- function(vlist, nthreads = 1L) {
    .Call('_ehmm_bindCols', PACKAGE = 'ehmm', vlist, nthreads)
}

bindCList <- function(clist, nthreads = 1L) {
    .Call('_ehmm_bindCList', PACKAGE = 'ehmm', clist, nthreads)
}

writeCountsTXT <- function(counts, marks, path) {
    invisible(.Call('_ehmm_writeCountsTXT', PACKAGE = 'ehmm', counts, marks, path))
}

writeCountsTXT_double <- function(counts, marks, path) {
    invisible(.Call('_ehmm_writeCountsTXT_double', PACKAGE = 'ehmm', counts, marks, path))
}

avgCountsPerClust <- function(counts, clusts) {
    .Call('_ehmm_avgCountsPerClust', PACKAGE = 'ehmm', counts, clusts)
}

tabf <- function(v, naRm = TRUE) {
    .Call('_ehmm_tabf', PACKAGE = 'ehmm', v, naRm)
}

tabf2 <- function(v1, v2, naRm = TRUE) {
    .Call('_ehmm_tabf2', PACKAGE = 'ehmm', v1, v2, naRm)
}

colSummary <- function(mat, type, nthreads = 1L) {
    .Call('_ehmm_colSummary', PACKAGE = 'ehmm', mat, type, nthreads)
}

getRef <- function(mat, type, nthreads = 1L) {
    .Call('_ehmm_getRef', PACKAGE = 'ehmm', mat, type, nthreads)
}

quantileNorm <- function(mat, ref, nthreads = 1L, seed = 13L) {
    .Call('_ehmm_quantileNorm', PACKAGE = 'ehmm', mat, ref, nthreads, seed)
}

qclist2mlist <- function(clist, nthreads = 1L) {
    .Call('_ehmm_clist2mlist', PACKAGE = 'ehmm', clist, nthreads)
}

mlist2clist <- function(mlist, nthreads = 1L) {
    .Call('_ehmm_mlist2clist', PACKAGE = 'ehmm', mlist, nthreads)
}

testSortCounts <- function(v) {
    .Call('_ehmm_testSortCounts', PACKAGE = 'ehmm', v)
}

testMeanAndMedian <- function(v, type) {
    .Call('_ehmm_testMeanAndMedian', PACKAGE = 'ehmm', v, type)
}

statesToSegments_helper <- function(regions, states) {
    .Call('_ehmm_statesToSegments_helper', PACKAGE = 'ehmm', regions, states)
}

segmentsToBed <- function(segments, labels, colors, path) {
    invisible(.Call('_ehmm_segmentsToBed', PACKAGE = 'ehmm', segments, labels, colors, path))
}

